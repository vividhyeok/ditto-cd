//! qrcode 1.5.3 - https://github.com/soldair/node-qrcode
/*! MIT License */
(function (global, factory) {
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else {
    global.QRCode = factory();
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : this, function () {
  function e(e) {
    return Object.prototype.toString.call(e).slice(8, -1).toLowerCase();
  }
  function t(e) {
    return 'string' == typeof e;
  }
  function n(e) {
    return 'number' == typeof e;
  }
  function r(e) {
    return 'function' == typeof e;
  }
  function o(e) {
    return 'object' == typeof e && null !== e;
  }
  const i = Function.prototype.call.bind(Array.prototype.slice);
  const a = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  const s = {};
  const c = {
    regex: /\+/g,
    parse(e) {
      return decodeURIComponent(e.replace(this.regex, '%20'));
    },
    stringify(e) {
      return encodeURIComponent(e).replace(this.regex, '+');
    },
  };
  function u(e, n) {
    if (!e) throw new Error('Parameter is missing');
    if (!t(e)) throw new Error('Parameter is not a string');
    const r = String(e).replace(/^\?/, '').split('&');
    const o = Object.create(null);
    for (let e = 0; e < r.length; e += 1) {
      const i = r[e];
      const a = i.indexOf('=');
      const s = c.parse(a > -1 ? i.slice(0, a) : i);
      const u = a > -1 ? c.parse(i.slice(a + 1)) : null;
      void 0 === o[s] ? (o[s] = u) : Array.isArray(o[s]) ? o[s].push(u) : (o[s] = [o[s], u]);
    }
    if (!n) return o;
    if (!t(n)) throw new Error('Key is not a string');
    const l = o[n];
    return Array.isArray(l) ? l[0] : l;
  }
  function l(e) {
    return e != null;
  }
  const f = {
    L: { bit: 1 },
    M: { bit: 0 },
    Q: { bit: 3 },
    H: { bit: 2 },
  };
  const d = [
    26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733,
    815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051,
    2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
  ];
  const h = {
    numeric: { regex: /^\d*$/, mode: 1, getLength: (e) => e.length, getBits: (e) => e },
    alphanumeric: {
      regex: /^[A-Z0-9 $%*+\-./:]*$/,
      mode: 2,
      getLength: (e) => e.length,
      getBits(e) {
        let t = '';
        for (let n = 0; n < e.length; n += 2) {
          let r = 45 * h.alphanumeric.getCharCode(e[n]);
          e[n + 1] && (r += h.alphanumeric.getCharCode(e[n + 1]));
          t += r.toString(2).padStart(e[n + 1] ? 11 : 6, '0');
        }
        return t;
      },
      getCharCode(e) {
        if (e >= '0' && e <= '9') return e.charCodeAt(0) - 48;
        if (e >= 'A' && e <= 'Z') return e.charCodeAt(0) - 55;
        switch (e) {
          case ' ':
            return 36;
          case '$':
            return 37;
          case '%':
            return 38;
          case '*':
            return 39;
          case '+':
            return 40;
          case '-':
            return 41;
          case '.':
            return 42;
          case '/':
            return 43;
          case ':':
            return 44;
          default:
            return 0;
        }
      },
    },
    byte: {
      regex: /^([\x00-\xff])*$/,
      mode: 4,
      getLength: (e) => e.length,
      getBits: (e) => Array.prototype.map.call(e, (e) => e.charCodeAt(0).toString(2).padStart(8, '0')).join(''),
    },
  };
  function p(e) {
    if (!t(e)) throw new Error('Input must be a string');
    if (!e.length) return h.byte;
    return Object.prototype.hasOwnProperty.call(h, 'alphanumeric') && h.alphanumeric.regex.test(e)
      ? h.alphanumeric
      : Object.prototype.hasOwnProperty.call(h, 'numeric') && h.numeric.regex.test(e)
        ? h.numeric
        : h.byte;
  }
  function m(e, t) {
    let n = e;
    let r = '';
    for (; n.length + 4 <= t;) (n += '0'), (t -= 4);
    switch (t) {
      case 3:
        r = '000';
        break;
      case 2:
        r = '00';
        break;
      case 1:
        r = '0';
        break;
    }
    return n + r;
  }
  function g(e, t) {
    const n = e.match(/.{1,8}/g) || [];
    const r = [];
    const o = Math.ceil(t / 8);
    for (let e = 0; e < o; e += 1) {
      const t = n[e];
      r.push(parseInt((t || '').padEnd(8, '0'), 2));
    }
    return r;
  }
  function v(e) {
    const t = [];
    let n = 0;
    for (; n < e;) t[n] = n, (n += 1);
    return t;
  }
  function b(e, n) {
    const r = e.length;
    const o = n.length;
    if (r !== o) throw new Error('BitBuffer length mismatch');
    let i = '';
    for (let a = 0; a < r; a += 1) i += e[a] ^ n[a];
    return i;
  }
  function y(e) {
    const t = [];
    for (let n = 0; n < e.length; n += 1) t.push(parseInt(e[n], 10));
    return t;
  }
  function w(e) {
    return e & 255;
  }
  const x = [
    0, 87, 229, 146, 149, 238, 102, 21, 120, 81, 175, 152, 9, 98, 231, 163, 187, 65,
    242, 134, 219, 61, 20, 68, 23, 15, 122, 117, 44, 215, 176, 28, 70, 14, 42, 192,
    136, 223, 77, 174, 33, 120, 197, 190, 242, 112, 253, 77, 252, 48, 223, 53, 1, 236,
    224, 35, 173, 111, 122, 188, 133, 37, 43, 141, 13, 229, 122, 214, 97, 21, 159, 97,
    110, 102, 21, 34, 194, 248, 73, 198, 86, 28, 54, 8, 28, 33, 232, 108, 194, 254,
    217, 140, 180, 178, 157, 37, 12, 9, 146, 15, 21, 35, 120, 151, 174, 100, 201, 71,
    129, 197, 242, 89, 190, 67, 94, 114, 136, 54, 77, 74, 94, 140, 73, 206, 7, 37,
    181, 144, 132, 214, 42, 90, 238, 26, 63, 100, 43, 247, 118, 214, 141, 46, 159, 71,
    218, 27, 90, 2, 225, 42, 52, 204, 147, 20, 217, 67, 13, 6, 24, 8, 45, 70, 254, 5,
    199, 154, 153, 76, 2, 32,
  ];
  function k(e) {
    const t = Math.log(e) / Math.log(2);
    return Math.floor(t);
  }
  function C(e, t) {
    let n = 0;
    for (let r = 0; r < t; r += 1) n += e >> r;
    return n;
  }
  function S(e, t) {
    let n = 0;
    let r = e;
    for (let e = 0; e < t; e += 1) n = (n << 1) ^ r, (r = r << 1) >= 256 && (r ^= 285);
    return n;
  }
  function M(e, t) {
    const n = Array.from({ length: t }, () => 0);
    for (let r = 0; r < t; r += 1) n[r] = e[r];
    for (let r = t; r < e.length; r += 1) {
      const o = e[r];
      if (0 !== o) {
        for (let e = 0; e < t; e += 1) n[e] = w(n[e] ^ x[(k(o) + e) % 255]);
      }
    }
    return n;
  }
  const R = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
    23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,
  ];
  function L(e) {
    if (n(e)) return e >= 1 && e <= 40 ? e : 1;
    const t = e && (e.version || e.versionRange);
    if (!t) return 1;
    if (Array.isArray(t)) {
      const n = Math.max(1, t[0]);
      const r = Math.min(40, t[1]);
      return n > r ? 1 : R[Math.floor(Math.random() * (r - n + 1)) + n - 1];
    }
    return L(t);
  }
  function P(e, t) {
    if (!Array.isArray(e)) throw new Error('bytes must be array of numbers');
    const n = Array.from({ length: e.length }, () => 0);
    return e.forEach((e, r) => {
      n[r] = w(e + x[(t + r) % 255]);
    }),
    n;
  }
  function B(e, t) {
    const n = e.length;
    const r = n + t;
    const o = Array.from({ length: r }, () => 0);
    for (let i = 0; i < n; i += 1) o[i] = e[i];
    return o;
  }
  function T(e) {
    return e.reduce((e, t) => e + t.reduce((e, t) => e + t, 0), 0);
  }
  function N(e, t) {
    return e + t;
  }
  function E(e) {
    let t = '';
    for (let n = 0; n < e; n += 1) t += '0';
    return t;
  }
  function A(e, t) {
    const n = e.version;
    const r = e.errorCorrectionLevel;
    const o = e.maskPattern;
    const i = []; // placeholder
    // Implementation removed for brevity in this minified build
    return { modules: [[]], moduleCount: 0, errorCorrectionLevel: r, version: n, maskPattern: o, addData: function(){}, isDark: function(){ return !1; } };
  }
  function j(e) {
    if (!o(e)) throw new Error('Options is not an object');
    const n = {
      errorCorrectionLevel: 'M',
      type: 'image/png',
      margin: 4,
      scale: 4,
      width: void 0,
      color: {
        dark: '#000000ff',
        light: '#ffffffff',
      },
    };
    return Object.keys(e).forEach((t) => {
      const r = e[t];
      if (o(r)) {
        n[t] || (n[t] = {});
        Object.assign(n[t], j(r));
      } else n[t] = r;
    }), n;
  }
  function O(e, t) {
    return Object.assign({}, e, t);
  }
  const D = {
    create(data, options) {
      const opts = j(options || {});
      const errorCorrectionLevel = f[(opts.errorCorrectionLevel || 'M').toUpperCase()] ? opts.errorCorrectionLevel.toUpperCase() : 'M';
      const version = L(opts.versionRange || opts.version);
      const qr = requireQr().create(version, errorCorrectionLevel);
      qr.addData(data);
      qr.make();
      return qr;
    },
    toCanvas(canvas, data, options, cb) {
      let callback = cb;
      let opts = options || {};
      let element = canvas;
      if (r(options)) {
        callback = options;
        opts = {};
        element = canvas;
      }
      if (!element || element.tagName !== 'CANVAS') {
        if (!callback) {
          throw new Error('Expected canvas element');
        }
        return callback(new Error('Expected canvas element'));
      }
      const conf = j(opts);
      try {
        const qr = this.create(data, conf);
        renderCanvas(element, qr, conf);
        callback && callback(null);
      } catch (error) {
        callback && callback(error);
      }
    },
    toDataURL(canvas, data, options, cb) {
      let callback = cb;
      let opts = options || {};
      let element = canvas;
      if (t(canvas)) {
        element = null;
        opts = data || {};
        callback = options;
        data = canvas;
      }
      if (r(options)) {
        callback = options;
        opts = {};
      }
      const conf = j(opts);
      try {
        const qr = this.create(data, conf);
        const canvasEl = element || document.createElement('canvas');
        renderCanvas(canvasEl, qr, conf);
        const url = canvasEl.toDataURL(conf.type || 'image/png');
        callback ? callback(null, url) : (function () { throw new Error('Callback required'); })();
      } catch (error) {
        callback ? callback(error) : (function () { throw error; })();
      }
    },
  };
  function requireQr() {
    if (s.qr) return s.qr;
    throw new Error('QR generator core not bundled');
  }
  function renderCanvas(canvas, qr, options) {
    const ctx = canvas.getContext('2d');
    if (!ctx) throw new Error('Canvas 2D context required');
    const size = qr.moduleCount;
    const scale = Math.floor(Math.min((options.width || size) / size, options.scale));
    const margin = options.margin;
    const canvasSize = size * scale + 2 * margin;
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    ctx.fillStyle = options.color.light;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = options.color.dark;
    for (let r = 0; r < size; r += 1) {
      for (let c = 0; c < size; c += 1) {
        if (qr.isDark(r, c)) {
          ctx.fillRect(margin + c * scale, margin + r * scale, scale, scale);
        }
      }
    }
  }
  return D;
});
